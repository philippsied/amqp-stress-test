\documentclass[	a4paper,
			11pt,
			titlepage,
			oneside,
			fleqn,
			listof=totoc,
			parskip,
			numbers=noenddot]{scrartcl}
\usepackage{package/ownstil}
\usepackage{package/owncmd}

\usepackage{float}

%\input{package/header}

\begin{document}
	
	
\section*{Zielstellung und Rahmenbedingungen}
	
	Diese Dokumentation beschäftigt sich mit dem Thema \glqq Angriffe auf AMQP-Messagebroker\grqq . Begleitend zur Vorlesung  \glqq Betriebliche Informationssysteme\grqq\/ galt es von uns in einem Praktikum zu identifizieren, welche potenziellen Angriffsvektoren existieren. Eingeschlossen ist hier auch das System \glqq RabbitMQ\grqq\/ welches das zu untersuchende Protokoll einschließt.

	Ziel ist es bestimmt Angriffsvektoren aufzuspüren und zu bewerten. Durch Implementierung von einzelnen Clients auf Basis der RabbitMQ Java-Bibliothek sollen die Angriffe veranschaulicht werden.  Mit veränderten Parametern richtet sich die Suche gezielt nach Faktoren die das System negativ beeinflussen und so die Verfügbarkeit stören, fokussiert auf \glqq Denial of Service\grqq. DoS kann dabei auf verschiedene Ressourcen bezogen sein (wie CPU, Arbeitsspeicher, Netzwerkbandbreite etc.).

	Um die Begrenzungen ausfindig zu machen, gehört es zu Beginn zu unsere Aufgabe angemessene Werkzeuge zur Beobachtung der Ressourcen zu finden. Nur dann ist es möglich die Angriffe zu bewerten und ihre tiefere Auswirkung zu untersuchen.

	Ferner sollen Vorschläge zur Schadensbegrenzung gegeben werden. Dazu gehört die Angabe auf welcher Ebene (Netzwerkebene, Protokollebene etc.) sich die Gefahren beseitigen lassen.



% ---------------------------------------------------------------------------------------------- %
%	
% -------------------------------------- Testumgebung ------------------------------------------ %
%
% ---------------------------------------------------------------------------------------------- %
\clearpage
\section*{Testumgebung}
	Als Betriebssystem für die Bereistellung des RabbitMQ-Servers wurde ein Ubuntu Server 14.04.2 LTS mit Kernel 3.16.0-30 verwendet. Das Testsysten wurde dabei als Virtuelle Maschine (VM) in der Virtualisierungslösung \glqq Virtualbox\grqq\ der Firma Oracle betrieben, um eine einfache Skalierung der Hardware, eine einfache Portabilität des Testsystem und einen reproduzierbaren Systemzustand, über die integrierte Snapshot-Funktion, bereitzustellen. Für die Konfiguration wurden die in Tabelle \ref{tab:testvm} dargestellten Einstellungen gewählt. 
	\begin{table}[!htb]
	\centering
	\begin{tabular}{p{3cm}|p{6cm}}
		\tsl{Host} 		& rabbitmqserver (192.168.178.153) \\\hline
		\tsl{Anz. CPU} 		& 2 \\
		\tsl{RAM} 		& 2048 MB \\
		\tsl{Grafikspeicher} 	& 12 MB \\
		\tsl{HDD} 		& 8,00 GB \\
		\tsl{Netzwerk}		& 1GB über Bridging durch lokales Netzwerk-Interface
	\end{tabular}
	\caption{Konfiguration der Test-VM}
	\label{tab:testvm}
	\end{table}

	Für die reproduzierbare Einrichtung der Testumgebung wurde ein BASH-Skript erstellt, welches sich im Repository des zugehörigen GitHub-Projektes befindet. Es setzt eine frische Installation 
	des Ubuntu Server voraus - ohne eine Vorauswahl an Softwarepacketen (z.\,B. LAMP). Vor der Ausführung des Skriptes sollte ein Snapshot erstellt werden. Anschließend kann es in der VM über:
	\begin{quote}
		\ttfamily 		
		\$\,> wget \url{https://raw.githubusercontent.com/philippsied/amqp-stress-test/master/utilities/setupTestEnv.sh}
	\end{quote}
	aus dem Git-Repository heruntergeladen werden. Da das Skript für die Einstellung des Netzwerkinterface Root-Rechte benötigt (Sudo-Rechte genügen nicht), muss der Root-User zuvor aktivert werden. Abschließend kann das Skript mit Sudo-Rechten ausgeführt werden:
	\begin{quote}
		\ttfamily 
		\$\,> sudo passwd root\\
		\$\,> sudo bash setupTestEnv.sh
	\end{quote}
	
	Nach Abschluss der Einrichtung erfolgt eine übersichtliche Ausgabe aller Informationen, einschließlich RabbitMQ-Benutzerdaten und Adressen.

	
	
	% Beschreibung Testrechner Szenario, VM-Rechner, Client


% ---------------------------------------------------------------------------------------------- %
%	
% --------------------------- Verwendete bzw. Erstellte Programme ------------------------------ %
%
% ---------------------------------------------------------------------------------------------- %
\clearpage
\section*{Verwendete bzw. Erstellte Programme}
	
	RabbitMQ bietet einige Anwendungen, mit denen sich die Leistungsfähigkeit der Server messen lässt. Alle Hilfsprogramme sind innerhalb der \textit{rabbitmq-client-tests.jar} vorzufinden. Diese JAR-Datei enthält weiterhin zahlreiche kleine Beispielprogramme für das Testen der Funktionalität des eigenen Servers. 
	
	\paragraph{VirtualBox} Der von uns verwendete Server wurde durch die Virtualisierungslösung VirtualBox realisiert. Neben der einfachen Installation neuer Gast-Systeme besteht die Möglichkeit Sicherheitspunkte zu erstellen. Bei einem Ausfall des System kann so der ursprüngliche Sicherungspunkt wiederhergestellt werden. Als Grundlage dient die Servervariante von Ubuntu 14.04 LTS, welche durch die fehlende grafische Oberfläche zum einsparen von Ressourcen dient.
	
	\paragraph{Glances} Glances ist ein System-Monitoring-Tool, das zahlreiche Informationen auf engstem Raum präsentiert. Im einfachsten Fall werden die gesammelten System-Informationen auf der Konsole ausgeben. Ferner ermöglicht ein integriertes Web-Interface eine Fernüberwachung der Umgebung. Zu den gesammelten Informationen gehören unter anderem: CPU-Auslastung, Kernel-Version, Speicherverbrauch (HDD, RAM) und laufende Prozesse. Hierbei werden alle Informationen im Sekundentakt aktualisiert.
	
	\paragraph{Perftest} ist ein Performance-Test-Tool, welches beliebig viele Producer und Consumer erstellt und die Sende-/Empfangsrate misst. Zusammen mit der Latenzzeit werden alle Angaben auf der Konsole ausgeben.

	\paragraph{HTML Performance Tools} bieten ebenfalls ein breites Spektrum an Funktionalität. Mit einer Reihe von Tools und Unterstützung von perftest lassen sich automatisierte Benchmarks erstellen. Die gelieferten Daten dienen dem Vergleich der Systems vor und während des Angriffs. Alle Ergebnisse werden in einer JSON-Datei gesichert und ansprechend in einer HTML-Seite dargestellt

	
	\paragraph{AMQPstress} Um die Auswirkungen der gewählten Angriffsvektoren testen zu können, wurde für jeden Angriff ein eigener Client implementiert. Grundlage bildet die Java-Library von RabbitMQ, die geeignete Funktionen zur Ansprache des Servers bereitstellt. Alle erstellten Clients lassen sich über bestimmte Parameter aufrufen und mit weiteren Einstellungen versehen. Welche Einstellungen zutreffen, lässt sich anhand dieses Dokuments erschließen. Auch zeigt sich, welche Parameter für einen erfolgreichen Angriff nötig sind. Hierzu gehört unter anderem die Anzahl an Producer und Consumer oder auch die gewählte Nachrichtengröße.



% ---------------------------------------------------------------------------------------------- %
%	
% ------------------------------ Beschreibung des Benchmarking --------------------------------- %
%
% ---------------------------------------------------------------------------------------------- %
\clearpage
\section*{Beschreibung des Benchmarking}
	
	Für die Beobachtung des Ressourcenverbrauches auf dem RabbitMQ-Server wurde das Kommandozeilenprogramm \tsl{glances} verwendet. Der Programmaufruf für jeden Test lautete wie folgt:
	\begin{quote}
		\ttfamily
		\$\,> sudo glances -t 5 -\,-disable-process -\,-export-csv measure.csv
	\end{quote}
	Er veranlasst, die Ansicht alle 5 Sekunden zu erneuern und die Anzeige der aktuell laufenden Prozesse abzuschalten, um den Ressourcenverbrauch durch \textsl{glances} selbst zu reduzieren.
	Die Messwerte werden dabei in eine CSV-Datei exportiert, welche später zur Visualisierung und Auswertung verwendet wurde.
	Vor jeder Messung wurde die VM auf einen Snapshot zurückgesetzt, bei der sich das System in einem Zustand befindet, den es 5 minuten nach dem Hochfahren der VM besitzt.
	
	\usecase{Leerlauf}%
		{Der RabbitMQ-Server befindet sich im Leerlauf, d.\,h. ohne irgendeine Form von Last.}%
		{Keine}%
		{Keine}%
		{%
		 \measure{CPU}{0.5\%}\\
		 \measure{RAM}{120MB (Verwendet)}\\
		 \measure{HDD}{785MB (Frei)}\\
		 \measure{NET}{RCX 3Kbit/s\quad TRX 197Kbit/s}%
		}%
		{Keine}
	
	\usecase{Anwendungsszenario}%
		{Ein Producer erzeugt kontinuierlich Nachrichten, die von einem Consumer kontinuierlich korrekt entnommen werden. Es finden keine weiteren Anfragen bzw. Zugriffe auf den RabbitMQ-Server statt.}%
		{%
		 Messdauer: 600s (10min)\\
		 1 Consumer \\
		 1 Producer \\
		 Nachrichtengröße: 1024 Byte\\
		 Max. 50 Nachrichten/s (Producer)
		}%
		{bash startBenchmark.sh testc:testp@192.168.178.153:5672/\%2f}%
		{%
		 \measure{CPU}{2\%}\\
		 \measure{RAM}{127MB (Verwendet)}\\
		 \measure{HDD}{785MB (Frei)}\\
		 \measure{NET}{RCX 299Kbit/s\quad TRX 370Kbit/s}%
		}%
		{
		 Die Sender/Empfangsrate sowie die Latenz sind wie erwartet weitgehend konstant. Die Latenz liegt durchschnittlich bei 1.3 ms.
		 (Siehe Abb. \ref{fig:std-server1}, \ref{fig:std-server2}, \ref{fig:std-scenario})
		}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/std/std_server1.png}
			\caption{Ohne Angriff - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:std-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/std/std_server2.png}
			\caption{Ohne Angriff - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:std-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/std/std_scenario.png}
			\caption{Ohne Angriff - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:std-scenario}
		\end{figure}
	


% ---------------------------------------------------------------------------------------------- %
%	
% -------------------------------- Beschreibung der Angriffe ----------------------------------- %
%
% ---------------------------------------------------------------------------------------------- %
\clearpage
\section*{Beschreibung der Angriffe}

	\attack{Referenzangriff - Kooperativer Client}%
		{%
		 Ein Producer erzeugt kontinuierlich Nachrichten die über einen \glqq fanout\grqq-Exchange an 5 Consumer verteilt werden. Die Consumer quittieren dem RabbitMQ-Server dabei den Erhalt der Nachricht.
		}{%
		 -dm ACK (Aufrufparameter für Angriff) \\
		 -c 5 (5 Consumer) \\
		 -i 10 (10ms Pause zwischen 2 Consumer/Producer-Anfragen) \\
		 -ms 10240 (Nachrichtengröße: 10KB) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 1 Producer (Standard) \\
		 Nicht-Persistente Nachrichten (Standard)
		}{%
		 Amqpstress -dm ACK -c 5 -i 10 -ms 10240 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}


	\attack{Ignorieren von Nachrichten}%
		{%
		 Ein Producer erzeugt kontinuierlich Nachrichten gewisser Größe mit zufälligem Inhalt, die von einem oder mehreren Consumern empfangen, aber nicht quittiert werden.
		 Der RabbitMQ-Server ist somit gezwungen, die Nachrichten in der Queue zwischenzuspeichern.
		}{%
		 -dm NO (Aufrufparameter für Angriff) \\
		 -c 5 (5 Consumer) \\
		 -i 10 (10ms Pause zwischen 2 Consumer/Producer-Anfragen) \\
		 -ms 10240 (Nachrichtengröße: 10KB) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 1 Producer (Standard) \\
		 Nicht-Persistente Nachrichten (Standard)
		}{%
		 Amqpstress -dm NO -c 5 -i 10 -ms 10240 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}


	\attack{Sofortiges Abweisen von Nachrichten}%
		{%
		 Ein Producer erzeugt kontinuierlich Nachrichten gewisser Größe mit zufälligem Inhalt, die von einem oder mehreren Consumern empfangen, aber sofort abgewiesen (basic.Reject) werden.
		 Der RabbitMQ-Server ist somit gezwungen, die Nachrichten in der Queue zwischenzuspeichern und erneut an den Consumer zu senden.
		}{%
		 -dm REJECT (Aufrufparameter für Angriff) \\
		 -c 5 (5 Consumer) \\
		 -i 10 (10ms Pause zwischen 2 Consumer/Producer-Anfragen) \\
		 -ms 10240 (Nachrichtengröße: 10KB) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 1 Producer (Standard) \\
		 Nicht-Persistente Nachrichten (Standard)
		}{%
		 Amqpstress -dm REJECT -c 5 -i 10 -ms 10240 -mp -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}
		
	
	\attack{Gebündeltes Abweisen von Nachrichten}%
		{%
		 Ein Producer erzeugt kontinuierlich Nachrichten gewisser Größe mit zufälligem Inhalt, die von einem oder mehreren Consumer empfangen, zunächst ignoriert werden, um sie bei erreichen eines Schwellwertes gebündelt abzuweisen (basic.NACK). Dadurch ist der RabbitMQ-Server gezwungen alle Nachrichten zwischenzuspeichern und stoßweise alle Nachrichten bis zu der aktuellen Sequenznummer erneut zuzustellen.
		}{%
		 -dm NACK (Aufrufparameter für Angriff) \\
		 Schwellwert: 1000 Nachrichten (Standard) \\
		 -c 5 (5 Consumer) \\
		 -i 10 (10ms Pause zwischen 2 Consumer/Producer-Anfragen) \\
		 -ms 10240 (Nachrichtengröße: 10KB) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 1 Producer (Standard) \\
		 Nicht-Persistente Nachrichten (Standard)
		}{%
		 Amqpstress -dm NACK -c 5 -i 10 -ms 10240 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}
		

	\attack{Queue-Churning}%
		{%
		 Ein Client erzeugt bis zu einem Schwellwert Queues und befüllt sie optional mit einer zufälligen Nachricht gegebener Größe. Wenn der Schwellwert an erzeugten Queues erreicht ist, werden alle Queues ohne zu Warten gelöscht und der Zyklus beginnt erneut. Der RabbitMQ-Server muss die Überreste der Queues im RAM bzw. der Festplatte bereinigen, während neue Queues angelegt und befüllt werden.
		}{%
		 -dq NO (Aufrufparameter für Angriff -Ohne Nachrichten) \\
		 -i 1 (1ms Pause zwischen Queue-Erzeugung) \\
		 -pc 100000 (Schwellwert: 100000 Queues) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 1 Client - Consumer und Producer zugleich (Standard) \\
		 Nicht-Persistente Nachrichten/Queues (Standard)
		}{%
		 Amqpstress -dq NO -i 1 -pc 100000 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}
		
		
		
	\attack{Nachrichten mit großem Header}%
		{%
		 RabbitMQ bietet die Möglichkeit im Header der Nachricht bestimmt Parameter für die Weiterleitung zu deklarieren. Dieser Test beschäftigt sich mit der Auswirkung, wenn der Header unnötig ausgelastet wird. Das System ist gezwungen alle Weiterleitungsoptionen zu Prüfen, auch wenn diese keinem Ziel entsprechen.
		}{%
		 -lh (Aufrufparameter für Angriff) \\
		 -i 10 (10ms Pause zwischen 2 Anfragen)
		 -ms 10000 (Nachrichtengröße: 10000 Byte) \\
		 -hs 2500 (Headergröße - Anzahl Einträge in Map) \\
		 -u <uri> (URI für Verbindung mit Server)
		}{%
		 Amqpstress -lh -i 10 -ms 10000 -hs 2500 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}

		
	\attack{Channel-Flooding}%
		{%
		 Neben einzelnen Verbindungen können in RabbitMQ auch mehrerer Kanäle aufgebaut werden. Hier stellt sich die Frage, wie das System mit einer Vielzahl von Kanäle zurecht kommt.
		 Auf Basis einer einzelnen Verbindung wird das System so ausgelastet und beobachtet.
		}{%
		 -mc (Aufrufparameter für Angriff) \\
		 -p 100 (100 Producer) \\
		 -c 10 (10 Consumer) \\
		 -ms 10000 (Nachrichtengröße: 10000 Byte) \\
		 -u <uri> (URI für Verbindung mit Server) \\		 
		}{%
		 Amqpstress -mc -p 100 -c 10 ms 10000 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}


	\attack{Ausbleiben von Commits im Transaktionsmodus}%
		{%
		 Im Transaktionsmodus ist es möglich mehrere Nachrichten als Folge zu übertragen, die aber vergleichbar mit Datenbanken als Einheit betrachtet werden. Nur durch die Commit()-Funktion
		 wird der neue Zustand angenommen und die Nachrichten im System zur Verfügung gestellt. Ferner kann mit der Rollback()-Funktion der ursprüngliche Zustand wiederhergestellt werden.
		 Zu untersuchen wäre die Situation, wenn permanent Nachrichten ohne commit gesendet werden - der Server muss die Nachrichten dann im Speicher belassen.
		}{%
		 -tx (Aufrufparameter für Angriff) \\
		 -p 5 (5 Producer) \\
		 -ms 10240 (Nachrichtengröße: 10KB) \\
		 -mct 100000 (Nachrichtenanzahl pro Producer: 100000) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 Commit auslassen (Standard)
		}{%
		 Amqpstress -tx -p 5 ms 10240 -mct 100000 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}
	
	
	\attack{Handshake-Trickle}%
		{%
		 In 9 Schritten 1s Pause
		}{%
		 -sh (Aufrufparameter für Angriff) \\
		 -i 0 (Keine Pause zwischen Ende Handshake und Beginn neuem Handshake) \\
		 -u <uri> (URI für Verbindung mit Server)
		}{%
		 Amqpstress -sh -i 0 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}


	\attack{Heartbeat-Flooding}%
		{%
		 .
		}{%
		 -hb (Aufrufparameter für Angriff) \\
		 -i 1 (1s Heartbeat Timeout) \\
		 -cl 20 (20 Clients) \\
		 -u <uri> (URI für Verbindung mit Server)
		}{%
		 Amqpstress -hb -i 1 -cl 20 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}


	\attack{TCP-Connection-Dropping}%
		{%
		 .
		}{%
		 -dc (Aufrufparameter für Angriff) \\
		 -i 100 (100ms Pause zwischen Connection Erzeugung) \\
		 -u <uri> (URI für Verbindung mit Server)
		}{%
		 Amqpstress -dc -i 100 -u amqp://testc:testp@192.168.178.153:5672/\%2f
		}
	


% ---------------------------------------------------------------------------------------------- %
%	
% -------------------------------- Auswirkungen der Angriffe ----------------------------------- %
%
% ---------------------------------------------------------------------------------------------- %
\clearpage
\section*{Auswirkungen der Angriffe}
	
	\report{Referenzangriff - Kooperativer Client}%
		{%
		 \measure{CPU}{13\%} \newline
		 \measure{RAM}{134MB (Verwendet)} \newline
		 \measure{HDD}{785MB (Frei)} \newline
		 \measure{NET}{RCX 5Mbit/s\quad TRX 42.8Mbit/s}
		}{%
		 Es ist keine Beeinträchtigung erkennbar. Die Nachrichtenraten liegen jeweils konstant bei 50 Nachrichten/s und die Latenz liegt bei durchschnittlich 1.3 ms.
		 (Siehe Abb. \ref{fig:ack-scenario}).
		}{%
		 Keine
		}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/ack/ack_server1.png}
			\caption{Kooperativer Client - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:ack-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/ack/ack_server2.png}
			\caption{Kooperativer Client - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:ack-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/ack/ack_scenario.png}
			\caption{Kooperativer Client - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:ack-scenario}
		\end{figure}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{Ignorieren von Nachrichten}
		{%
		 \measure{CPU}{9\%} \newline
		 \measure{RAM}{362MB (Verwendet)} \newline
		 \measure{HDD}{593MB (Frei)} \newline
		 \measure{NET}{RCX 3.8Mbit/s\quad TRX 33.8Mbit/s}
		}{%
		 Die Nachrichten werden bis zur Hälfte des eingestellten Limits (hier ~500MB) im RAM gehalten, bei überschreiten der Grenze lagert der RabbitMQ-Server die Nachrichten im Hintergrund auf die Festplatte aus.
		 Hierbei entsteht eine CPU-Lastspitze, welche in Abb. \ref{fig:no-server1} deutlich bei ca. 260s zu sehen ist und sich direkt auf die Latenz im Anwendungsszenario auswirkt (Siehe Abb. \ref{fig:no-scenario}). Durch die Freigabe des RAM-Speichers entsteht ein Sägezahnmuster. Dieser Vorgang wiederholt sich bis der standardmäßig gesetzte Schwellwert erreicht ist und der Server alle Verbindungen schließt und in diesem Zustand verweilt. Der Ressourcenverbrauch sinkt auf den Leerlauf-Zustand.
		}{%
		 In der aktuellen Implementierung des Angriffes hat der Client ebenfalls einen hohen Bedarf an Arbeitsspeicher, da die Client-Bibliothek die empfangene Nachricht für jeden Consumer
		 separat zwischenspeichert.
		}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/no/no_server1.png}
			\caption{Ignorieren von Nachrichten - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:no-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/no/no_server2.png}
			\caption{Ignorieren von Nachrichten - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:no-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/no/no_scenario.png}
			\caption{Ignorieren von Nachrichten - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:no-scenario}
		\end{figure}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{Sofortiges Abweisen von Nachrichten}%
		{%
		 \measure{CPU}{24\%} \newline
		 \measure{RAM}{467MB (Verwendet)} \newline
		 \measure{HDD}{603MB (Frei)} \newline
		 \measure{NET}{RCX 4.2Mbit/s\quad TRX 28.2Mbit/s}
		}{%
		 .
		}{%
		 .
		}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/reject/reject_server1.png}
			\caption{Sofortiges Abweisen von Nachrichten - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:reject-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/reject/reject_server2.png}
			\caption{Sofortiges Abweisen von Nachrichten - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:reject-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/reject/reject_scenario.png}
			\caption{Sofortiges Abweisen von Nachrichten - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:reject-scenario}
		\end{figure}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{Gebündeltes Abweisen von Nachrichten}%
		{%
		 \measure{CPU}{15\%} \newline
		 \measure{RAM}{534MB (Verwendet)} \newline
		 \measure{HDD}{572MB (Frei)} \newline
		 \measure{NET}{RCX 4.2Mbit/s\quad TRX 81.8Mbit/s}
		}{%
		.
		}{
		.
		}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/nack/nack_server1.png}
			\caption{Gebündeltes Abweisen von Nachrichten - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:nack-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/nack/nack_server2.png}
			\caption{Gebündeltes Abweisen von Nachrichten - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:nack-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/nack/nack_scenario.png}
			\caption{Gebündeltes Abweisen von Nachrichten - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:nack-scenario}
		\end{figure}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{Queue-Churning}%
		{%
		 \measure{CPU}{44\%} \newline
		 \measure{RAM}{1542MB (Verwendet)} \newline
		 \measure{HDD}{784MB (Frei)} \newline
		 \measure{NET}{RCX 265kbit/s\quad TRX 358kbit/s}
		}{%
		.
		}{%
		. 
		}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/queue/queue_server1.png}
			\caption{Queue-Churning - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:queue-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/queue/queue_server2.png}
			\caption{Queue-Churning - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:queue-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/queue/queue_scenario.png}
			\caption{Queue-Churning - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:queue-scenario}
		\end{figure}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{Ausbleiben von Commits im Transaktionsmodus}%
		{
		 \measure{CPU}{2\%} \newline
		 \measure{RAM}{955MB (Verwendet)} \newline
		 \measure{HDD}{785MB (Frei)} \newline
		 \measure{NET}{RCX 924kbit/s\quad TRX 83bit/s}%
		}{
		 Durch Auslassen des Commits steigt der Speicherverbrauch stark an. Nach wenigen Sekunden ist die Speichergrenze erreicht und keine weiteren Nachrichten werden übertragen. Daraufhin verharren alle Producer bis der Speicher wieder freigegeben wird (Falls Consumer vorhanden).
		}{
		 Die Messung des Andwendungsszenario konnte bei diesem Angriff nicht durchgeführt werden, da das dafür verwendete Tool \glqq HTML Performance Tools\grqq\ bei der Messung reproduzierbar einfriert.
		}

		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/tx/tx_server1.png}
			\caption{Ausbleiben von Commits im Transaktionsmodus - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:commit-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/tx/tx_server1.png}
			\caption{Ausbleiben von Commits im Transaktionsmodus - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:commit-server2}
		\end{figure}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{Nachrichten mit großem Header}%
		{%
		 \measure{CPU}{2\%} \newline
		 \measure{RAM}{468MB (Verwendet)} \newline
		 \measure{HDD}{391MB (Frei)} \newline
		 \measure{NET}{RCX  2.8Mbit/s\quad TRX 33kbit/s}%
		}{%
		 Die Anwendung generiert zu Beginn 2500 Weiterleitungsoptionen (Bestehend aus 8 Byte Key und 36 Byte Value = 44 Byte pro Eintrag) und schreibt sie in den Header jeder Nachricht. Hierdurch ist das System stark ausgelastet und der Durchsatz der Nachrichten schrumpft stark auf 10 - 20 Nachrichten pro Sekunde. Es macht keinen Unterschied ob der Key oder Value vergrößert wird, die geringe Übertragungsrate bleibt bestehen. Der Value wird daher nicht ausgewertet. Die Headergröße ist bei etwa 2500 Weiterleitungsoptionen begrenzt. Wird diese überschritten lässt das System die Verbindung fallen, aufgrund einer zu großen Framegröße. Die Framegröße lässt sich beim Aufbau der Verbindung angeben, kann aber die bereits voreingestellten eingestellten 128 Byte nicht überschreiten.
		}{%
		 Die Messung des Andwendungsszenario konnte bei diesem Angriff nicht durchgeführt werden, da das dafür verwendete Tool \glqq HTML Performance Tools\grqq\ bei der Messung reproduzierbar einfriert.
		}

		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/header/header_server1.png}
			\caption{Nachrichten mit großem Header - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:header-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/header/header_server2.png}
			\caption{Nachrichten mit großem Header - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:header-server2}
		\end{figure}
				
		\begin{table}[!htb]
			\centering
			\begin{tabular}{p{3cm}ll|p{3cm}}
				\multicolumn{3}{l|}{Übertragungsrate nach Nachrichtengröße}  & Headergröße     \\
				10.000 Byte          & 1.000 Byte              & 100 Byte    & Einträge (Byte) \\ \hline
				140m/s               & 260m/s                  & 350m/s      & 200 (8.800)     \\
				80m/s                & 120m/s                  & 180m/s      & 500 (22.000)    \\
				30m/s                & 50m/s                   & 70m/s       & 1.000 (44.000)  \\
				20m/s                & 30m/s                   & 40m/s       & 2.000 (88.000)  \\
				10m/s                & 10m/s                   & 20m/s       & 2.500 (110.000) \\ \hline
				270m/s               & 3.000m/s                & 10.000m/s   & kein Eintrag
			\end{tabular}
			\caption{Vergleich Headergröße}
		\end{table}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{Channel-Flooding}%
		{%
		 \measure{CPU}{76\%} \newline
		 \measure{RAM}{298MB (Verwendet)} \newline
		 \measure{HDD}{785MB (Frei)} \newline
		 \measure{NET}{RCX 116.7Mbit/s\quad TRX 205.0Mbit/s}
		}{%
		 Das System ist stark ausgelastet. Ähnelt aber der Auslastung unter der Erstellung mehrerer Verbindungen. Allerdings beansprucht  der Aufbau der Channel extrem viel Zeit. Nach Aufbau aller Kanäle bricht die Übertragungsrate stark ein.
		}{%
		 Zeit für Aufbau der Channel hängt stark von der Anzahl von Producer und Consumer ab. Nachfolgend zeigt sich ein Vergleich von mehreren Kanälen sowie mehreren Verbindungen.
		}

		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/channel/channel_server1.png}
			\caption{Channel-Flooding - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:channel-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/channel/channel_server2.png}
			\caption{Channel-Flooding - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:channel-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/channel/channel_scenario.png}
			\caption{Channel-Flooding - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:channel-scenario}
		\end{figure}
		
		\begin{table}[!htb]
			\centering
			\begin{tabular}{p{3cm}llp{3cm}}
				Übertragungsrate\newline (schreiben) & Producer & Consumer & Nachrichtengröße\newline (Byte) \\ \hline
				7.000m/s                             & 100      & 10       & 100                              \\
				800m/s                               & 100      & 10       & 1.000                            \\
				100m/s                               & 100      & 10       & 10.000
			\end{tabular}
			\caption{Mehrere Channel}
		\end{table}

		\begin{table}[!htb]
			\centering
			\begin{tabular}{p{3cm}llp{3cm}}
				Übertragungsrate\newline (schreiben) & Producer & Consumer & Nachrichtengröße\newline (Byte) \\ \hline
				24.000m/s                            & 100      & 10       & 100                             \\
				2.000m/s                             & 100      & 10       & 1.000                           \\
				100m/s                               & 100      & 10       & 10.000
			\end{tabular}
			\caption{Mehrere Verbindungen}
		\end{table}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{Handshake-Trickle}%
		{%
		 \measure{CPU}{2\%} \newline
		 \measure{RAM}{125MB (Verwendet)} \newline
		 \measure{HDD}{785MB (Frei)} \newline
		 \measure{NET}{RCX 293kbit/s\quad TRX 355kbit/s}
		}{%
		 1.4ms Latenz; 50Nachrichten/s; Handshake Timout bei 10s, ignoriert Anfrage zum heraufsetzen.
		}{%
		. 
		}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/handshake/handshake_server1.png}
			\caption{Handshake-Trickle - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:handshake-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/handshake/handshake_server2.png}
			\caption{Handshake-Trickle - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:handshake-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/handshake/handshake_scenario.png}
			\caption{Handshake-Trickle - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:handshake-scenario}
		\end{figure}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{Heartbeat-Flooding}%
		{%
		 \measure{CPU}{4\%} \newline
		 \measure{RAM}{134MB (Verwendet)} \newline
		 \measure{HDD}{785MB (Frei)} \newline
		 \measure{NET}{RCX 318kbit/s\quad TRX 386kbit/s}
		}{%
		 1.4ms, 50Nachrichten/s
		}{%
		. 
		}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/heartbeat/heartbeat_server1.png}
			\caption{Heartbeat-Flooding - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:heartbeat-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/heartbeat/heartbeat_server2.png}
			\caption{Heartbeat-Flooding - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:heartbeat-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/heartbeat/heartbeat_scenario.png}
			\caption{Heartbeat-Flooding - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:heartbeat-scenario}
		\end{figure}
	
	
%-------------------------------------------------------------------------------------------
	\clearpage
	\report{TCP-Connection-Dropping}%
		{%
		 \measure{CPU}{2\%} \newline
		 \measure{RAM}{416MB (Verwendet)} \newline
		 \measure{HDD}{785MB (Frei)} \newline
		 \measure{NET}{RCX 303kbit/s\quad TRX 522kbit/s}
		}{%
		 1.4ms, 50Nachrichten/s
		}{%
		. 
		}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/tcpdrop/tcpdrop_server1.png}
			\caption{TCP-Connection-Dropping - Verlauf des Speicherbedarfs für RAM/HDD und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:tcpdrop-server1}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/tcpdrop/tcpdrop_server2.png}
			\caption{TCP-Connection-Dropping - Verlauf der Transfer-, Empfangsrate und Verlauf der CPU-Last auf dem RabbitMQ-Server}
			\label{fig:tcpdrop-server2}
		\end{figure}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=\textwidth]{img/tcpdrop/tcpdrop_scenario.png}
			\caption{TCP-Connection-Dropping - Verlauf der Transfer-, Empfangsrate und Verlauf der Latenz im Anwendungsszenario}
			\label{fig:tcpdrop-scenario}
		\end{figure}
		
		
\clearpage
\section*{Ausblick}




\clearpage
\section*{Zusammenfassung und Fazit}

\end{document}
