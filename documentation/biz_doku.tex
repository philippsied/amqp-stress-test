\documentclass[	a4paper,
			11pt,
			titlepage,
			oneside,
			fleqn,
			listof=totoc,
			parskip,
			chapterprefix=false,
			numbers=noenddot]{scrartcl}
\usepackage{package/ownstil}
\usepackage{package/owncmd}

\usepackage{float}

%\input{package/header}

\begin{document}
%	\maketitle\clearpage
	
	
\section*{Zielstellung und Rahmenbedingungen}
	
	Diese Dokumentation beschäftigt sich mit dem Thema \glqq Angriffe auf AMQP-Messagebroker\grqq . Begleitend zur Vorlesung  \glqq Betriebliche Informationssysteme\grqq\/ galt es von uns in einem Praktikum zu identifizieren, welche potenziellen Angriffsvektoren existieren. Eingeschlossen ist hier auch das System \glqq RabbitMQ\grqq\/ welches das zu untersuchende Protokoll einschließt.

	Ziel ist es bestimmt Angriffsvektoren aufzuspüren und zu bewerten. Durch Implementierung von einzelnen Clients auf Basis der RabbitMQ Java-Bibliothek sollen die Angriffe veranschaulicht werden.  Mit veränderten Parametern richtet sich die Suche gezielt nach Faktoren die das System negativ beeinflussen und so die Verfügbarkeit stören, fokussiert auf \glqq Denial of Service\grqq. DoS kann dabei auf verschiedene Ressourcen bezogen sein (wie CPU, Arbeitsspeicher, Netzwerkbandbreite etc.).

	Um die Begrenzungen ausfindig zu machen, gehört es zu Beginn zu unsere Aufgabe angemessene Werkzeuge zur Beobachtung der Ressourcen zu finden. Nur dann ist es möglich die Angriffe zu bewerten und ihre tiefere Auswirkung zu untersuchen.

	Ferner sollen Vorschläge zur Schadensbegrenzung gegeben werden. Dazu gehört die Angabe auf welcher Ebene (Netzwerkebene, Protokollebene etc.) sich die Gefahren beseitigen lassen.

\clearpage
\section*{Testumgebung}
	Als Betriebssystem für die Bereistellung des RabbitMQ-Servers wurde ein Ubuntu Server 14.04.2 LTS mit Kernel 3.16.0-30 verwendet. Das Testsysten wurde dabei als Virtuelle Maschine (VM) in der Virtualisierungslösung \glqq Virtualbox\grqq\ der Firma Oracle betrieben, um eine einfache Skalierung der Hardware, eine einfache Portabilität des Testsystem und einen reproduzierbaren Systemzustand, über die integrierte Snapshot-Funktion, bereitzustellen. Für die Konfiguration wurden die in Tabelle \ref{tab:testvm} dargestellten Einstellungen gewählt. 
	\begin{table}[!htb]
	\centering
	\begin{tabular}{p{3cm}|p{6cm}}
		\tsl{Host} 		& rabbitmqserver (192.168.178.153) \\\hline
		\tsl{Anz. CPU} 		& 2 \\
		\tsl{RAM} 		& 2048 MB \\
		\tsl{Grafikspeicher} 	& 12 MB \\
		\tsl{HDD} 		& 8,00 GB \\
		\tsl{Netzwerk}		& 1GB über Bridging durch lokales Netzwerk-Interface
	\end{tabular}
	\caption{Konfiguration der Test-VM}
	\label{tab:testvm}
	\end{table}

	Für die reproduzierbare Einrichtung der Testumgebung wurde ein BASH-Skript erstellt, welches sich im Repository des zugehörigen GitHub-Projektes befindet. Es setzt eine frische Installation 
	des Ubuntu Server voraus - ohne eine Vorauswahl an Softwarepacketen (z.\,B. LAMP). Vor der Ausführung des Skriptes sollte ein Snapshot erstellt werden. Anschließend kann es in der VM über:
	\begin{quote}
		\ttfamily 		
		\$\,> wget \url{https://raw.githubusercontent.com/philippsied/amqp-stress-test/master/utilities/setupTestEnv.sh}
	\end{quote}
	aus dem Git-Repository heruntergeladen werden. Da das Skript für die Einstellung des Netzwerkinterface Root-Rechte benötigt (Sudo-Rechte genügen nicht), muss der Root-User zuvor aktivert werden. Abschließend kann das Skript mit Sudo-Rechten ausgeführt werden:
	\begin{quote}
		\ttfamily 
		\$\,> sudo passwd root\\
		\$\,> sudo bash setupTestEnv.sh
	\end{quote}
	
	Nach Abschluss der Einrichtung erfolgt eine übersichtliche Ausgabe aller Informationen, einschließlich RabbitMQ-Benutzerdaten und Adressen.
	
	
\clearpage
\section*{Verwendete bzw. Erstellte Programme}
	
	RabbitMQ bietet einige Anwendungen, mit denen sich die Leistungsfähigkeit der Server messen lässt. Alle Hilfsprogramme sind innerhalb der \textit{rabbitmq-client-tests.jar} vorzufinden. Diese JAR-Datei enthält weiterhin zahlreiche kleine Beispielprogramme für das Testen der Funktionalität des eigenen Servers. 
	
	\paragraph{VirtualBox} Der von uns verwendete Server wurde durch die Virtualisierungslösung VirtualBox realisiert. Neben der einfachen Installation neuer Gast-Systeme besteht die Möglichkeit Sicherheitspunkte zu erstellen. Bei einem Ausfall des System kann so der ursprüngliche Sicherungspunkt wiederhergestellt werden. Als Grundlage dient die Servervariante von Ubuntu 14.04 LTS, welche durch die fehlende grafische Oberfläche zum einsparen von Ressourcen dient.
	
	\paragraph{Glances} ...
	
	\paragraph{Perftest} ist ein Performance-Test-Tool, welches beliebig viele Producer und Consumer erstellt und die Sende-/Empfangsrate misst. Zusammen mit der Latenzzeit werden alle Angaben auf der Konsole ausgeben.

	\paragraph{HTML Performance Tools} bieten ebenfalls ein breites Spektrum an Funktionalität. Mit einer Reihe von Tools und Unterstützung von perftest lassen sich automatisierte Benchmarks erstellen. Die gelieferten Daten dienen dem Vergleich der Systems vor und während des Angriffs. Alle Ergebnisse werden in einer JSON-Datei gesichert und ansprechend in einer HTML-Seite dargestellt

	
	\paragraph{AMQPstress} ...
	
\clearpage
\section*{Beschreibung des Benchmarking}

	\usecase{Direkte Nachrichten 1:1}%
		{Ein Producer erzeugt kontinuierlich Nachrichten, die von einem Consumer kontinuierlich korrekt entnommen werden.}%
		{perfTest -h}%
		{}

	Für die Beobachtung des Ressourcenverbrauches auf dem RabbitMQ-Server wurde das Kommandozeilenprogramm \tsl{glances} verwendet. Der Programmaufruf für jeden Test lautete wie folgt:
	\begin{quote}
		\ttfamily
		\$\,> sudo glances -t 5 -\,-disable-process
	\end{quote}
	Er veranlasst, die Ansicht alle 5 Sekunden zu erneuern und die Anzeige der aktuell laufenden Prozesse abzuschalten, um den Ressourcenverbrauch durch \textsl{glances} selbst zu reduzieren.
	
\clearpage
\section*{Beschreibung der Angriffe}

	Beschreibung Standard Anwendung 1 Producer 5 Consumer während Anwendungsszenario läuft. Beschreibung Ressourcenverbrauch.

\clearpage
	\attack{Ignorieren von Nachrichten}%
		{Ein Producer erzeugt kontinuierlich Nachrichten gewisser Größe mit zufälligem Inhalt, die von einem oder mehreren Consumern empfangen, aber nicht quittiert werden.%
		 Der RabbitMQ-Server ist somit gezwungen, die Nachrichten in der Queue zwischenzuspeichern.}%
		{%
		 -dm NO (Aufrufparameter für Angriff) \\
		 -c 5 (5 Consumer) \\
		 -i 10 (10ms Pause zwischen 2 Consumer/Producer-Anfragen) \\
		 -ms 102400 (Messagegröße: 10KB) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 1 Producer (Standard) \\
		 Nicht-Persistente Nachrichten (Standard)
		}%
		{Amqpstress -dm NO -c 5 -i 10 -ms 102400 -u amqp://testc:testp@localhost:5672/\%2f}%
		{Nachrichten werden bis zur Hälfte des eingestellten Limits (hier ~400MB) im RAM gehalten, bei überschreiten lagert der RabbitMQ-Server im Hintergrund die Nachrichten auf die Festplatte aus. Durch die Freigabe des RAM-Speichers entsteht ein Sägezahnmuster. Dieser Vorgang wiederholt sich bis die Festplatte voll ist und RabbitMQ alle Verbindungen schließt und in diesem Zustand verweilt.CPU-Last liegt konstant bei ca. 10\%.}%
		{Verwendung von persistenten Nachrichten (-mp) steigert CPU-Last um x\%.}
		
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=0.9\textwidth]{img/noResp/history_RAM_HDD.png}
		\end{figure}
	
%------------------------------------------------------------------------------
\clearpage	
	\attack{Sofortiges Abweisen von Nachrichten}%
		{Ein Producer erzeugt kontinuierlich Nachrichten gewisser Größe mit zufälligem Inhalt, die von einem oder mehreren Consumern empfangen, aber sofort abgewiesen (basic.Reject) werden.%
		 Der RabbitMQ-Server ist somit gezwungen, die Nachrichten in der Queue zwischenzuspeichern und erneut an den Consumer zu senden.}%
		{%
		 -dm REJECT (Aufrufparameter für Angriff) \\
		 -c 5 (5 Consumer) \\
		 -i 10 (10ms Pause zwischen 2 Consumer/Producer-Anfragen) \\
		 -ms 102400 (Messagegröße: 10KB) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 1 Producer (Standard) \\
		 Nicht-Persistente Nachrichten (Standard)
		}%
		{Amqpstress -dm REJECT -c 5 -i 10 -ms 102400 -mp -u amqp://testc:testp@localhost:5672/\%2f}%
		{}%
		{Verwendung von persistenten Nachrichten (-mp) steigert CPU-Last um x\%.}
	
%------------------------------------------------------------------------------
\clearpage	
	\attack{Gebündeltes Abweisen von Nachrichten}%
		{Ein Producer erzeugt kontinuierlich Nachrichten gewisser Größe mit zufälligem Inhalt, die von einem oder mehreren Consumer empfangen, zunächst ignoriert werden, um sie bei erreichen eines Schwellwertes gebündelt abzuweisen (basic.NACK). Dadurch ist der RabbitMQ-Server gezwungen alle Nachrichten zwischenzuspeichern und stoßweise alle Nachrichten bis zu der aktuellen Sequenznummer erneut zuzustellen.}%
		{%
		 -dm NACK (Aufrufparameter für Angriff) \\
		 Schwellwert: 1000 Nachrichten (Standard) \\
		 -c 5 (5 Consumer) \\
		 -i 10 (10ms Pause zwischen 2 Consumer/Producer-Anfragen) \\
		 -ms 102400 (Messagegröße: 10KB) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 1 Producer (Standard) \\
		 Nicht-Persistente Nachrichten (Standard)
		}%
		{Amqpstress -dm NACK -c 5 -i 10 -ms 102400 -u amqp://testc:testp@localhost:5672/\%2f}%
		{}
		
%------------------------------------------------------------------------------
\clearpage
	\attack{Anlegen und Löschen von Queues}%
		{Ein Client erzeugt bis zu einem Schwellwert Queues und befüllt sie mit einer zufälligen Nachricht gegebener Größe. Wenn der Schwellwert erreicht ist, werden alle Queues ohne zu Warten gelöscht und der Zyklus beginnt erneut. Der RabbitMQ-Server muss die Überreste der Queues im RAM bzw. der Festplatte bereinigen, während neue Queues angelegt und befüllt werden.}%
		{%
		 -dq (Aufrufparameter für Angriff) \\
		 -pc 10 (Schwellwert: 10 Queues) \\
		 -i 10 (10ms Pause zwischen 2 Consumer/Producer-Anfragen) \\
		 -ms 0 (Keine Nachrichten senden) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 1 Client - Consumer und Producer zugleich (Standard) \\
		 Nicht-Persistente Nachrichten (Standard)
		}%
		{Amqpstress -dq -pc 10 -i 10 -ms 0  -u amqp://testc:testp@localhost:5672/\%2f}%
		{}

%------------------------------------------------------------------------------
\clearpage
	\attack{Versenden von  Nachrichten mit großem Header}%
		{RabbitMQ bietet die Möglichkeit im Header der Nachricht bestimmt Parameter für die Weiterleitung zu deklarieren. Dieser Test beschäftigt sich mit der Auswirkung, wenn der Header unnötig ausgelastet wird. Das System ist gezwungen alle Weiterleitungsoptionen zu Prüfen, auch wenn diese keinem Ziel entsprechen.}%
		{%
		 -lh (Aufrufparameter für Angriff) \\
		 -ms 10000 (Messagegröße: 10000 Byte) \\
		 -hs 2500 (Headergröße - Anzahl Einträge in Map) \\
		 -u <uri> (URI für Verbindung mit Server)
		}%
		{Amqpstress -lh -ms 10000 -hs 2500 -u amqp://testc:testp@localhost:5672}%
		{Die Anwendung generiert zu Beginn 2500 Weiterleitungsoptionen (Bestehend aus 8 Byte Key und 36 Byte Value = 44 Byte pro Eintrag) und schreibt sie in den Header jeder Nachricht. Hierdurch ist das System stark ausgelastet und der Durchsatz der Nachrichten schrumpft stark auf 10 - 20 Nachrichten pro Sekunde. Es macht keinen Unterschied ob der Key oder Value vergrößert wird, die geringe Übertragungsrate bleibt bestehen. Der Value wird daher nicht ausgewertet. Die CPU Last liegt bei 10 -15\%}
		{Die Headergröße ist bei etwa 2500 Weiterleitungsoptionen begrenzt. Wird diese überschritten lässt das System die Verbindung fallen, aufgrund einer zu großen Framegröße. Die Framegröße lässt sich beim Aufbau der Verbindung angeben, kann aber die bereits voreingestellten eingestellten 128 Byte nicht überschreiten.}

%\vspace{-0.35cm}
\begin{table}[h]
\centering
\begin{tabular}{lll|l}
\multicolumn{3}{l|}{\begin{tabular}[c]{@{}l@{}}Übertragungsrate nach Nachrichtengröße\end{tabular}} & Headergröße     \\
10.000 Byte                       & 1.000 Byte                       & 100 Byte                       & Einträge (Byte) \\ \hline
140m/s                            & 260m/s                           & 350m/s                         & 200 (8.800)     \\
80m/s                             & 120m/s                           & 180m/s                         & 500 (22.000)    \\
30m/s                             & 50m/s                            & 70m/s                          & 1.000 (44.000)  \\
20m/                              & 30m/s                            & 40m/s                          & 2.000 (88.000)  \\
10m/s                             & 10m/s                            & 20m/s                          & 2.500 (110.000) \\ \hline
270m/s                            & 3.000m/s                         & 10.000m/s                      & kein Eintrag   
\end{tabular}
\end{table}

%------------------------------------------------------------------------------
\clearpage		
	\attack{Aufbauen mehrerer Channel über eine einzelne Verbindung}%
		{Neben einzelnen Verbindungen können in RabbitMQ auch mehrerer Kanäle aufgebaut werden. Hier stellt sich die Frage, wie das System mit einer Vielzahl von Kanäle zurecht kommt. Auf Basis einer einzelnen Verbindung wird das System so ausgelastet und beobachtet. }%
		{%
		 -mc (Aufrufparameter für Angriff) \\
		 -ms 10000 (Messagegröße: 10000 Byte) \\
		 -u <uri> (URI für Verbindung mit Server) \\
		 -p 100 (100 Producer) \\
		 -c 10 (10 Consumer)
		}%
		{Amqpstress -mc -p 100 -c 10 -ms 10000 -u amqp://testc:testp@localhost:5672}%
		{Das System ist stark ausgelastet. Ähnelt aber der Auslastung unter der Erstellung mehrerer Verbindungen. Allerdings beansprucht  der Aufbau der Channel extrem viel Zeit. Nach Aufbau aller Kanäle bricht die Übertragungsrate stark ein. Dabei liegt die CPU-Last bei etwa 45 - 55\%}
		{Zeit für Aufbau der Channel hängt stark von der Anzahl von Producer und Consumer ab. Nachfolgend zeigt sich ein Vergleich von mehreren Kanälen sowie mehreren Verbindungen.}

\begin{table}[h]
\centering
\caption{Mehrere Channel}
\begin{tabular}{llll}
\begin{tabular}[c]{@{}l@{}}Übertragungsrate\\ (schreiben)\end{tabular} & Producer & Consumer & \begin{tabular}[c]{@{}l@{}}Nachrichtengröße\\ (Byte)\end{tabular} \\ \hline
7.000m/s                                                               & 100      & 10       & 100                                                               \\
800m/s                                                                 & 100      & 10       & 1.000                                                             \\
100m/s                                                                 & 100      & 10       & 10.000                                                           
\end{tabular}
\end{table}

\begin{figure}[ht]
	\vspace{0.5cm}
	\centering
	\includegraphics[width=0.9\textwidth]{img/channel/100ch100ms}
\end{figure}

\begin{table}[H]
\centering
\caption{Mehrere Verbindungen}
\begin{tabular}{llll}
\begin{tabular}[c]{@{}l@{}}Übertragungsrate\\ (schreiben)\end{tabular} & Producer & Consumer & \begin{tabular}[c]{@{}l@{}}Nachrichtengröße\\ (Byte)\end{tabular} \\ \hline
24.000m/s                                                              & 100      & 10       & 100                                                               \\
2.000m/s                                                               & 100      & 10       & 1.000                                                             \\
100m/s                                                                 & 100      & 10       & 10.000                                                           
\end{tabular}
\end{table}

\begin{figure}[H]
	\vspace{0.5cm}
	\centering
	\includegraphics[width=0.9\textwidth]{img/channel/100con100ms}
\end{figure}

%------------------------------------------------------------------------------
\clearpage
	\attack{Commit mehrerer Nachrichten im Transaktionsmodus}%
		{Im Transaktionsmodus ist es möglich mehrere Nachrichten als Folge zu übertragen, die aber vergleichbar mit Datenbanken als Einheit betrachtet werden. Nur durch die Commit()-Funktion wird der neue Zustand angenommen und die Nachrichten im System zur Verfügung gestellt. Ferner kann mit der Rollback()-Funktion der ursprüngliche Zustand wiederhergestellt werden. Zu untersuchen wäre die Situation, wenn permanent Nachrichten ohne commit gesendet werden - der Server muss die Nachrichten dann im Speicher belassen. }%
		{%
		 -tx (Aufrufparameter für Angriff) \\
		 -p 100 (100 Producer) \\
		 -ms 10000 (Messagegröße: 10000 Byte) \\
		 -mct 10000 (Nachrichtenanzahl pro Producer: 10000) \\
		 -co false (Commit der Transaktion - hier: Auslassen) \\
		 -u <uri> (URI für Verbindung mit Server)
		}%
		{Amqpstress -tx -p 100 -ms 10000 -mct 10000 -co false -u amqp://testc:testp@localhost:5672}%
		{Durch Auslassen des Commits steigt der Speicherverbrauch stark an. Nach wenigen Sekunden ist die Speichergrenze erreicht und keine weiteren Nachrichten werden übertragen. Daraufhin verharren alle Producer bis der Speicher wieder freigegeben wird (Falls Consumer vorhanden) }
		{Sporadisch friert der RabbitMQ-Server bei diesem Versuch ein. Ein Aufbau einer neuen Verbindung schlägt fehl und die Weboberfläche ist nicht mehr erreichbar. Nach längerer Zeit (etwa 10 Minuten) baut der Server aber wieder die Verbindungen ab und ein Zugriff ist wieder möglich. Dennoch bleibt der Speicherverbrauch bestehen.}

\begin{figure}[H]
	\vspace{0.5cm}
	\centering
	\includegraphics[width=0.9\textwidth]{img/commit/noCommit100p}
\end{figure}

%------------------------------------------------------------------------------
\clearpage
	\attack{Verzögerung des Verbindungsaufbaues}%
		{.}%
		{%
		 -u <uri> (URI für Verbindung mit Server)
		}%
		{Amqpstress  -u amqp://testc:testp@localhost:5672}%
		{}
		{}
		
%------------------------------------------------------------------------------
\clearpage
	\attack{Ausnutzung des Hearthbeats}%
		{.}%
		{%
		 -u <uri> (URI für Verbindung mit Server)
		}%
		{Amqpstress  -u amqp://testc:testp@localhost:5672}%
		{}
		{}
		
\clearpage
\section*{Auswirkungen der Angriffe}
	
	
	
\clearpage
\section*{Zusammenfassung und Fazit}

\end{document}
